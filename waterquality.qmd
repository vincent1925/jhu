---
title: "Water Quality Draft"
author: "Vincent Zheng"
date: 6/25/2024"
latex-auto-mk: true
output: html_document
format:
  html:
    code-fold: show
    code-tools: 
      source: true
      toggle: true
---

```{python}

import pandas as pd
import numpy as np
import geopandas as gpd
import matplotlib.pyplot as plt
import geopandas as gpd

pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', 50)

``` 


# Getting the tables

```{python}

# water quality data
cols = ['Water System Number', 'Population Served', 'Sampling Point Name', 'Sample Date', 'Analyte Name', 'Result', 'Counting Error', 'Units of Measure', 'Less Than Reporting Level', 'Reporting Level', 'DLR', 'MCL']
water1 = pd.read_table("SDWIS1.tab", encoding="ISO-8859-1", usecols=cols, dtype={20: str})
water2 = pd.read_table("SDWIS2.tab", encoding="ISO-8859-1", usecols=cols, dtype={20: str})
water3 = pd.read_table("SDWIS3.tab", encoding="ISO-8859-1", usecols=cols, dtype={20: str})
water4 = pd.read_table("SDWIS4.tab", encoding="ISO-8859-1", usecols=cols, dtype={20: str})
water = pd.concat([water1, water2, water3, water4])

# mortality data
cols = ['Year','ZIP_Code','Strata','Strata_Name','Cause','Cause_Desc','Count'] # dropped 'Annotation_Code','Annotation_Desc','Data_Revision_Date','ICD_Revision', 'Geography_Type'
mortality1 = pd.read_csv("cali_deaths_2009-2018.csv", usecols=cols)
mortality2 = pd.read_csv("cali_deaths_20019-2022.csv", usecols=cols)
mortality = pd.concat([mortality1, mortality2])

water_geo = gpd.read_file('California_Drinking_Water_System_Area_Boundaries/California_Drinking_Water_System_Area_Boundaries.shp')
zip_geo = gpd.read_file('california_zip_codes/California_Zip_Codes.shp')

```

# Cleaning Mortality Data

As we've discussed, I kept only the general cause of mortality. Additionally, I seperated out the strata by gender, age, and total. We'll be focusing on age and I'll be adjusting mortality rates for age in the future. I dropped the data in years 2009 and 2010 because we're using water data starting from 2011.

```{python}

# filtering out causes from mortality 
cause_list = ["ALZ", "CAN", "CLD", "DIA", "HOM", "HTD", "HYP", "INJ", "LIV", "NEP", "PAR", "PNF", "STK", "SUI"]
mortality = mortality[~mortality["Cause"].isin(cause_list)]
mortality = mortality.rename(columns={"ZIP_Code": "ZIP_CODE"})

# drop rows that are in years 2009 and 2010 in mortality
mortality = mortality[~mortality["Year"].isin([2009, 2010])]

# filling in NaN values with 0
mortality["Count"] = mortality["Count"].fillna(0)

# mortality with only age as strata 
mortality_age = mortality[mortality["Strata"] == "Age"]

# mortality with total population as strata
mortality_total = mortality[mortality["Strata"] == "Total Population"]
mortality_total = mortality_total.drop(columns=["Strata", "Cause", "Cause_Desc"])

# mortality with gender as strata
mortality_gender = mortality[mortality["Strata"] == "Gender"]

```

# Cleaning Water Data

I dropped the data in years 2023 and 2024 because we're using mortality data up to 2022. I used the boundaries data to get the zip codes of the office corresponding to each water system. I also stripped the trailing whitespace.

```{python}

# make a new column in water that gets the year under sample date
water["Sample Year"] = water["Sample Date"].str.split("-").str[2]
water = water.drop(columns=["Sample Date"])

# drop rows that are in years 2023 and 2024
water = water[~water["Sample Year"].isin(["2023", "2024"])] 

# removing trailing whitespace
water["Water System Number"] = water["Water System Number"].str.rstrip() 
water["Analyte Name"] = water["Analyte Name"].str.rstrip() 

```

# Merging Water Data with Boundaries

```{python}

# keeping only the relevant columns
water_geo = water_geo.loc[:, ["WATER_SYST", "geometry"]] 
zip_geo = zip_geo.loc[:, ["ZIP_CODE", "geometry"]]
  # note that water_geo has 4798 rows instead of 4776 rows because of water systems that have mutliple geometries. this is solved when intersecting with zip_geo

# repairing invalid geometries which solves the nan values when sjoining
water_geo['geometry'] = water_geo['geometry'].make_valid()
zip_geo['geometry'] = zip_geo['geometry'].make_valid()

# ensures same mapping
zip_geo = zip_geo.to_crs(water_geo.crs)

# the zip codes that each water system serves
# NEED TO FIX BACK TO LEFT
water_zip = gpd.sjoin(water_geo, zip_geo, how='inner', predicate='intersects')
water_zip = water_zip.drop(columns=['index_right', 'geometry']).reset_index(drop=True)
water_zip["ZIP_CODE"] = water_zip["ZIP_CODE"].astype(int)

water_zip_grouped = water_zip.groupby('WATER_SYST')['ZIP_CODE'].apply(lambda x: ', '.join(str(x))).reset_index()

``` 

# Fixed Effects Regression

```{python}

# join mortality_total and water_zip on zip code
df = pd.merge(mortality_total, water_zip, on="ZIP_CODE", how="left")

# calculate the average count every year of each water system using zip codes
average_count = df.groupby(['WATER_SYST', 'Year'])['Count'].mean().reset_index()


```

```{python}

# getting the chloroform concentration for each water system for each year
chloroform = water[water['Analyte Name'] == 'CHLOROFORM'].reset_index(drop=True)

# fixes the row with a "                " as the result
chloroform['Result'] = pd.to_numeric(chloroform['Result'], errors='coerce')

# replace NaN values with 0
chloroform['Result'] = chloroform['Result'].fillna(0)

# make result float
chloroform['Result'] = chloroform['Result'].astype(float)
chloroform['Sample Year'] = chloroform['Sample Year'].astype(int)


chloroform = chloroform.groupby(['Water System Number', 'Sample Year'])['Result'].mean().reset_index()

chloroform = chloroform.rename(columns={"Water System Number": "WATER_SYST", "Sample Year": "Year"})

```

```{python}

df['WATER_SYST'] = df['WATER_SYST'].astype(str)
chloroform['WATER_SYST'] = chloroform['WATER_SYST'].astype(str)

merged_data = pd.merge(df, chloroform, how = 'inner', on=['WATER_SYST', 'Year'])

# show rows with NaN values
df[df.isnull().any(axis=1)]

# drop Strata_Name and WATER_SYST
merged_data = merged_data.drop(columns=['Strata_Name', 'WATER_SYST'])

merged_data = merged_data.set_index(['ZIP_CODE', 'Year'])

display(merged_data)

```

```{python}

from linearmodels import PanelOLS


mod = PanelOLS.from_formula(
  "Count ~ Result + EntityEffects + TimeEffects", merged_data)

twfe = mod.fit()
print(twfe)

```

```{python}

# get the rows where the zip code appears more than once in water_zip
water_duplicates = water_zip[water_zip.duplicated(keep = False, subset = ["WATER_SYST"])]

water_duplicates_91709 = water_duplicates[water_duplicates["ZIP_CODE"] == 91709]
water_duplicates_91709

```

```{python}

import statsmodels.api as sm

# Merge water data with mortality data
merged_data = pd.merge(water, mortality_age, on=["ZIP_CODE", "Year"], how="inner")

# Create dummy variables for zip code-year fixed effects
zip_year_dummies = pd.get_dummies(merged_data["ZIP_CODE"].astype(str) + merged_data["Year"].astype(str), prefix="zip_year")

# Add the dummy variables to the merged data
merged_data = pd.concat([merged_data, zip_year_dummies], axis=1)

# Define the dependent variable
y = merged_data["Mortality_Rate"]

# Define the independent variables
X = merged_data[["Concentration1", "Concentration2", "Concentration3", "Concentration4", "Concentration5"] + list(zip_year_dummies.columns)]

# Add a constant term to the independent variables
X = sm.add_constant(X)

# Fit the fixed effects regression model
model = sm.OLS(y, X)
results = model.fit()

# Print the regression results
print(results.summary())

```

# Viewing water systems with multiple geometries

```{python}

water_duplicates = water_geo[water_geo.duplicated(keep = False, subset = ["WATER_SYST"])]

water_system_zip_codes = water_geo[water_geo['WATER_SYST'].isin(water_duplicates['WATER_SYST'])]

water_system_zip_codes

```

# Scrap

```{python}

# merging water with boundaries

# leave only the columns water system number and the zip code of boundaries
boundaries_zip = boundaries.loc[:, ["WATER_SYSTEM_NUMBER", "ADDRESS_ZIP_CODE"]]

# preparing the zip code column for merging
boundaries_zip = boundaries_zip.rename(columns={"ADDRESS_ZIP_CODE": "ZIP_Code"})
boundaries_zip["ZIP_Code"] = boundaries_zip["ZIP_Code"].fillna("0")

# removing the last four digits of the zip code
sep = '-'
boundaries_zip["ZIP_Code"] = boundaries_zip["ZIP_Code"].str.split(sep).str[0]
boundaries_zip["ZIP_Code"] = boundaries_zip["ZIP_Code"].astype(str)

# merging water with boundaries on water system number
water = water.rename(columns={"Water System Number": "WATER_SYSTEM_NUMBER"})

water_boundaries = pd.merge(water, boundaries_zip, on="WATER_SYSTEM_NUMBER", how="left")
water_boundaries

```



